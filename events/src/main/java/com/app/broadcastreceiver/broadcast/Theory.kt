package com.app.broadcastreceiver.broadcast

/**
    BroadcastReceiver в Android — это компонент, который позволяет приложению получать и обрабатывать широковещательные сообщения (broadcasts) от системы или других приложений. Эти сообщения могут касаться различных системных событий или действий пользователя, таких как изменения состояния сети, получение SMS, завершение загрузки, изменение времени и т.д. Важно понимать, как работать с BroadcastReceiver, чтобы эффективно и безопасно использовать его в приложениях.

    Для Senior Android разработчика важно не только знать базовые принципы работы с BroadcastReceiver, но и понимать более сложные аспекты, такие как производительность, безопасность и правильное использование механизмов регистрации.

    Основные аспекты работы с BroadcastReceiver:

    1. Основная концепция
    BroadcastReceiver — это компонент, который может слушать и обрабатывать широковещательные сообщения (broadcasts).
    Широковещательные сообщения могут быть:
    Системными (например, изменения состояния сети, подключение зарядного устройства).
    Пользовательскими (собственными для приложения или других приложений).
    Система отправляет broadcasts для уведомлений, таких как:

    ACTION_BATTERY_LOW — уведомление о низком заряде батареи.
    ACTION_TIME_CHANGED — изменение времени.
    CONNECTIVITY_CHANGE — изменение состояния сети.

    2. Регистрация BroadCastReceiver
    Существует два способа регистрации:

    В манифесте:

    Регистрация через манифест позволяет приложению слушать широковещательные сообщения даже тогда, когда оно не активно.
    Однако это имеет некоторые ограничения, так как манифестные BroadcastReceiver могут прослушивать только публичные сообщения, а также они не могут быть использованы для более специфичных задач, где важно учитывать контекст (например, конкретное состояние активности или фрагмента).

    Пример:
    <receiver android:name=".MyReceiver">
    <intent-filter>
    <action android:name="android.intent.action.BATTERY_LOW" />
    </intent-filter>
    </receiver>
    Важно понимать, что все компоненты, зарегистрированные в манифесте, будут работать на уровне всего приложения.
    Динамическая регистрация (через Context.registerReceiver()):

    При динамической регистрации приложение может регистрировать и отменять регистрацию BroadcastReceiver в определенные моменты времени, что дает больше контроля.

    Это позволяет, например, слушать события только в определенных активностях или фрагментах, что экономит ресурсы.

    Пример:
    BroadcastReceiver receiver = new MyReceiver();
    IntentFilter filter = new IntentFilter(Intent.ACTION_BATTERY_LOW);
    registerReceiver(receiver, filter);
    Важно помнить, что динамически зарегистрированные receivers необходимо отключать в onPause() или onDestroy(), чтобы предотвратить утечку памяти:

    unregisterReceiver(receiver);

    3. Понимание типов сообщений
    Обычные сообщения (Normal Broadcasts): Они отправляются без ожидания ответа и обрабатываются асинхронно.

    Ожидающие (Ordered Broadcasts): В этом случае сообщения передаются по очереди между разными приемниками. Каждый приемник может либо изменить данные сообщения, либо передать их дальше. Это даёт больше контроля, но также может замедлить обработку, так как обработка будет идти по цепочке.

    Пример:
    sendOrderedBroadcast(intent, null);

    4. Производительность
    Использование широковещательных сообщений в Android может оказывать влияние на производительность, особенно когда речь идет о системных событиях, таких как ACTION_TIME_TICK, которые генерируются каждую секунду. Поэтому важно тщательно планировать, какие BroadcastReceiver нужно регистрировать.
    Использование локальных BroadCastReceiver: В Android есть возможность использовать LocalBroadcastManager, который ограничивает область распространения широковещательных сообщений только внутри приложения. Это более эффективно по производительности, так как не создает дополнительных затрат на межпроцессные взаимодействия.

    Пример:
    LocalBroadcastManager localBroadcastManager = LocalBroadcastManager.getInstance(context);
    localBroadcastManager.sendBroadcast(new Intent("MY_ACTION"));

    5. Безопасность
    Отправка сообщений: Приложение может отправлять свои собственные широковещательные сообщения, а также принимать сообщения от других приложений. Однако, важно обеспечить безопасность в случаях, когда ваше приложение отправляет или получает sensitive данные.

    Permissions: В случае если приложение хочет слушать определённые события, оно может требовать наличия прав доступа, например, для доступа к данным или системным событиям. Эти права нужно правильно настроить как для динамической, так и для статической регистрации:

    Копировать код
    <receiver android:name=".MyReceiver" android:permission="android.permission.ACCESS_NETWORK_STATE">
    <intent-filter>
    <action android:name="android.net.conn.CONNECTIVITY_CHANGE"/>
    </intent-filter>
    </receiver>
    BroadcastReceiver с разрешениями: Когда ваше приложение отправляет широковещательные сообщения, можно установить разрешения на их прием, чтобы другие приложения не могли их перехватить.

    6. Управление жизненным циклом:
    Важно правильно управлять жизненным циклом BroadcastReceiver, особенно при динамической регистрации. Если не отменить регистрацию в нужный момент, это может привести к утечкам памяти.
    Если BroadcastReceiver долго работает в фоновом режиме (например, слушает системные события в onReceive()), следует учитывать последствия для производительности и потенциальные проблемы с энергопотреблением.

    7. Использование с JobScheduler или WorkManager
    Для выполнения задач в фоне рекомендуется использовать JobScheduler (до Android 5.0) или WorkManager (для более современных версий), чтобы гарантировать выполнение задач, даже если приложение было закрыто. В случае использования BroadcastReceiver можно комбинировать его с такими компонентами для выполнения задач в фоновом режиме.
    Пример с WorkManager:

    OneTimeWorkRequest workRequest = new OneTimeWorkRequest.Builder(MyWorker.class)
    .setInputData(workData)
    .build();
    WorkManager.getInstance(context).enqueue(workRequest);

    Подводя итог:
    Senior Android разработчик должен знать, как эффективно и безопасно использовать BroadcastReceiver, учитывать производительность, безопасность и управление жизненным циклом.
    Важно делать правильный выбор между статической и динамической регистрацией, минимизировать влияние на производительность и следить за утечками памяти.
    Разработчик также должен учитывать возможности, такие как LocalBroadcastManager, JobScheduler, и WorkManager, для реализации более сложных решений.
    Применение этих знаний позволяет создавать более оптимизированные и безопасные приложения.
 * */