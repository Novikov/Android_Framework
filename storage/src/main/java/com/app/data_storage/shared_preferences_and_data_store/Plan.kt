package com.app.data_storage.shared_preferences_and_data_store

/**
Shared Preferences
    -Доступ через context
    -apply команда асинхронно, commit запишет синхронно. В первую очередь используем apply, commit если перед перезагрузкой приложения например
    -Слушатель
    -Проблемы: Несоответствие типов при записи и вытаскивания значений

Data Store - библиотека
-Типизированный ключ
-Поддерживает RxJava и корутины из коробки

SharedPreferences имеет только 1 асинхронный метод записи который выполнится негарантированно

SharedPreferences предоставляет два метода для сохранения данных: apply() и commit(). Они оба позволяют сохранять данные в фоновом потоке, но есть важные отличия, о которых стоит поговорить:

apply():

Этот метод асинхронен в том смысле, что не блокирует вызывающий поток. Он выполняет операцию записи в память, а затем сохраняет данные на диск в фоновом потоке.
Однако, важно понимать, что apply() не ждет завершения записи на диск. Он сразу завершает выполнение и не сообщает об успешности или неудаче операции.
Это может привести к ситуации, когда данные не будут немедленно сохранены на диск, и если приложение завершится до этого, изменения могут быть утеряны (хотя это маловероятно для большинства случаев, поскольку запись на диск происходит быстро).

DataStore использует корутины и предоставляет API для работы с данными через suspend функции, что позволяет более четко контролировать, когда и как происходят операции записи и чтения.

Почему DataStore был создан?
Асинхронность:

SharedPreferences работает синхронно, что может быть проблемой в многозадачных приложениях, где нужно делать операции ввода-вывода в фоновом потоке. Это может блокировать главный поток и ухудшать производительность. Даже если вы используете корутины для асинхронных операций, вам всё равно приходится оборачивать вызовы в дополнительные конструкции, чтобы избежать блокировки.
DataStore работает асинхронно "из коробки". Он использует корутины и Flow для асинхронной работы, что упрощает код и позволяет работать с данными без блокировки потока UI. Он также использует suspend функции, что делает работу с ним более удобной и безопасной.
Обработка ошибок:

В SharedPreferences ошибки при записи и чтении данных не всегда очевидны, так как они могут не выбрасывать исключения, а просто игнорироваться.
DataStore использует более строгую обработку ошибок, что помогает избежать скрытых багов. Например, ошибки при работе с файловой системой могут быть выброшены как исключения, и их можно будет обработать через стандартные механизмы обработки ошибок.
Поддержка типов данных:

SharedPreferences работает только с примитивными типами данных (например, String, Boolean, Int, Long, Float), что делает его неудобным для хранения сложных объектов. Для сохранения сложных объектов вам нужно сериализовать их вручную, что добавляет дополнительные сложности и потенциальные источники ошибок.
DataStore поддерживает более гибкие структуры данных, такие как Proto и Preferences. Вы можете хранить сложные объекты в сериализованном формате (например, с помощью Protocol Buffers), что позволяет лучше управлять структурированными данными и избегать проблем с сериализацией/десериализацией.
Скалируемость и устойчивость:

В SharedPreferences данные хранятся в одном большом файле, что может стать проблемой для масштабных приложений. Если вы постоянно добавляете или удаляете записи, это может привести к ненужным накладным расходам на операции ввода-вывода и плохой производительности.
DataStore может работать с несколькими файлами данных, что позволяет более эффективно управлять данными, и автоматически оптимизирует операции ввода-вывода. Это делает его более подходящим для приложений с большими объемами данных.
Консистентность данных:

В SharedPreferences нет встроенной поддержки для обеспечения консистентности данных, если происходит сбой приложения, например, при записи данных.
DataStore использует механизмы журналирования и транзакций, что помогает избежать частичных записей и повышает надежность данных.
 * */