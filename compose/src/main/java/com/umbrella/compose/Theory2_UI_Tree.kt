package com.umbrella.compose

/**
    В Jetpack Compose, структура UI-дерева отличается от традиционного подхода с использованием View и ViewGroup. Compose использует декларативный подход, где UI описывается с помощью функций, и весь интерфейс представляется в виде дерева компонентов. Однако, несмотря на разницу в реализации, основные принципы иерархии остаются схожими с тем, как это происходит в традиционных View-системах.

    Основные элементы UI-дерева в Compose:
    Window — это корень иерархии, который отображает ваш Compose UI в Activity.
    SetContent — это точка, где вы передаете композируемые функции для отображения контента в вашем Activity или Fragment.
    Composable функции — это основные строительные блоки UI в Compose, такие как Column, Row, Text, Button и другие.

    1. Window и Root View
    Каждое приложение в Android с Compose начинается с Window, как и в традиционной системе Android. Однако Window на уровне Compose не используется напрямую. Вместо этого используется метод setContent, который помогает привязать Compose UI к экрану.

    Window — это контейнер, в который встраивается UI, и он управляет тем, как отображается Activity.
    DecorView и Root View — в традиционном Android эти элементы занимались тем, что вставляли UI в контейнеры, такие как LinearLayout, FrameLayout, и т. д. В Compose этот уровень абстракции скрыт, и интерфейс определяется через setContent и другие компоненты Compose.

    2. setContent и Composable функции
    Когда вы используете setContent в Android, вы передаете Composable функцию, которая строит ваш UI, определяя, какие компоненты и как должны быть отображены.

    setContent {
    MyApp()
    }
    Composable функции — это компоненты интерфейса, которые могут быть объединены в иерархию, создавая дерево элементов. Они определяют визуальное содержимое экрана и взаимодействия с ним.

    3. Composable функции в UI-дереве (LayoutNode примерно как ViewGroup во View)
    Вот пример того, как будет выглядеть UI-дерево в Compose для следующего интерфейса:

    kotlin
    Копировать код
    @Composable
    fun MyApp() {
    Column {
    Text("Hello, World!")
    Button(onClick = { /* do something */ }) {
    Text("Click Me")
    }
    Image(painter = painterResource(id = R.drawable.sample_image), contentDescription = "Sample Image")
    }
    }
    Это создаст структуру, похожую на традиционное дерево UI, но с использованием компонентов Compose.

    Полная структура UI-дерева для Compose:
    Window (Activity)
    │
    └── DecorView (внутренний контейнер для UI)
    │
    └── ComposeRoot (Корневой контейнер, созданный setContent)
    │
    └── Column (Контейнер для вертикальной верстки)
    │
    ├── Text ("Hello, World!") (Текстовый элемент)
    │
    ├── Button (Кнопка)
    │   └── Text ("Click Me") (Текст внутри кнопки)
    │
    └── Image (Изображение)

    Разбор структуры:
    Window — это корневой контейнер для отображения всего экрана приложения. В Android приложение всегда привязано к Window, но в Compose это более абстрактный процесс, скрытый внутри setContent.
    DecorView — это контейнер, который уже работает на уровне Android и управляет всем UI. В контексте Compose он инкапсулирует все элементы UI и работает с ними как с деревом компонентов.
    ComposeRoot — это объект, создаваемый системой Compose, который начинает процесс компоновки UI. Он управляет состоянием всех последующих композируемых функций и передает их в систему рендеринга.
    Column — в Compose это контейнер, который упорядочивает дочерние элементы в вертикальном направлении, аналогично LinearLayout с вертикальной ориентацией в традиционном Android. Все элементы внутри Column будут отображаться один под другим.
    Text — это элемент, который отображает текстовое содержимое. В данном случае это "Hello, World!".
    Button — стандартная кнопка. Внутри нее содержится текстовый элемент, который является дочерним элементом кнопки.
    Image — это элемент для отображения изображения, который принимает ресурс изображения в качестве параметра.

    Важные моменты:
    В Jetpack Compose не существует явных контейнеров, как в традиционном Android (LinearLayout, RelativeLayout и т. д.). Вместо этого используются такие функции, как Column, Row, Box, которые определяют способ отображения и позиционирования дочерних элементов.
    Composable функции могут быть вложены друг в друга, создавая дерево UI-компонентов. Например, Column может содержать Text, Button, и другие компоненты, и каждый из них в свою очередь может иметь дочерние компоненты, такие как текст в кнопке.
    UI-поток в Compose работает с деревом компонентов и автоматически обновляет только те части UI, которые изменились, благодаря системе управления состоянием и recomposition.
 * */